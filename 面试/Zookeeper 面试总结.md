# Zookeeper 面试总结

## 1：Zookeeper是什么？

　　ZooKeeper是一个开源的分布式协调服务，是集群的管理者，监视集群节点反馈信息进行下一步合理操作。

　　Zookeeper提供的服务：管理用户程序提交的数据；为用户程序提供节点监听服务。

　　应用场所：主从协调，服务器节点动态上下线，负载均衡、集群管理等。。。

　　**Zookeeper=文件系统+通知机制**

## 2：Zookeeper特性

- 一致性
  - 顺序一致性：从同一个客户端发起的事务请求，最终将会严格按照其发起顺序被应用到zookeeper中去；
- 原子性
  - 要么整个集群所有机器都成功应用了某一个事务，要么都没有应用，一定不会出现集群中部分机器应用了该事务，而另外一部分没有应用的情况；
- 单一视图
  - 无论客户端连接的是哪个zookeeper服务器，其看到的服务器算数据模型都是一致的；
- 可靠性
  - 一旦服务端成功得应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更会一致被保留下来，除非有另外一个事务又对其进行了变更；
- 实时性
  - zookeeper仅仅保证在一定的时间段内，客户端最终一定能够从服务端上读取到最新的数据状态。

## 3：Zookeeper集群的角色： Leader 、follower 和 Observer

　 Leader：事物请求的唯一调度和处理者，集群内部服务的调度者。

　 followe： 参与Leader选举投票、处理客户端的非事物请求，转发事物请求给Leader服务器、参与事物请求Proposal的投票

　 Observer：弱化版的Follower，不参与任何投票，主要是为了在不影响集群事务处理能力的前提下提升集群的非事务处理的吞吐量。

## 4：Zookeeper集群机制的

半数机制：集群中半数以上机器存活，集群可用。

## 5：Zookeeper提供的功能？

 1）小文件系统；

 2）watcher监控机制；

 3）选举制度

## 6：Zookeeper协议

ZAB协议，一种支持崩溃恢复的原子广播协议。

### ZAB协议是什么？

​        ZAB协议是一种专门为zookeeper设计的一种支持崩溃回复的原子广播协议，是一种通用的分布式一致性算法，基于该协议，zookeeper实现了一种主备模式的系统架构来保持集群中各副本之间数据的一致性。具体来说，zookeeper使用一个单一的主进程来接收并处理客户端的所有事务请求，并采用ZAB的原子广播协议，将服务器数据的状态变更为以事务的形式广播到所有的副本进程上去，该协议的这个主备模式架构保证了同一时刻集群中只能够有一个主进程来广播服务器的状态变更。

​        简言之，该协议核心就是定义了对于那些会改变zookeeper服务器数据状态的事务请求的处理方式，所有事务请求都必须由一个全局唯一的服务器来协调处理，即leader服务器。


## 7：四种类型的数据节点-znode

　　PERSISTENT-持久节点    persistent
　　EPHEMERAL-临时节点   ephemeral
　　PERSISTENT_SEQUENTIAL-持久顺序节点  persistent_sequential
　　EPHEMERAL_SEQUENTIAL-临时顺序节点  ephemeral_sequential

## 8：zookeeper-watcher-机制----数据变更通知

　　Zookeeper允许客户端向服务端的某个Znode注册一个Watcher监听，当服务端的一些指定事件触发了这个Watcher，服务端会向指定客户端发送一个事件通知来实现分布式的通知功能，然后客户端根据Watcher通知状态和事件类型做出业务上的改变。

　　工作机制：客户端注册watcher，服务端处理watcher，客户端回调watcher

##  9：Watcher特性总结

- 一次性
- 客户端串行执行
- 轻量
- 异步

## 10：客户端注册Watcher实现

1. 调用getData()/getChildren()/exist()三个API，传入Watcher对象

2. 标记请求request，封装Watcher到WatchRegistration

3. 封装成Packet对象，发服务端发送request

4. 收到服务端响应后，将Watcher注册到ZKWatcherManager中进行管理

5. 请求返回，完成注册。

## 11：服务端处理Watcher实现

1. 服务端接收Watcher并存储

2. Watcher触发

3. 调用process方法来触发Watcher

## 12：客户端回调Watcher

　　客户端SendThread线程接收事件通知，交由EventThread线程回调Watcher。客户端的Watcher机制同样是一次性的，一旦被触发后，该Watcher就失效了。

## 13：Zookeeper 下 Server工作状态

　　服务器具有四种状态，分别是LOOKING、FOLLOWING、LEADING、OBSERVING。

　　LOOKING：寻找Leader状态。当服务器处于该状态时，它会认为当前集群中没有Leader，因此需要进入Leader选举状态。

　　FOLLOWING：跟随者状态。表明当前服务器角色是Follower。

　　LEADING：领导者状态。表明当前服务器角色是Leader。

　　OBSERVING：观察者状态。表明当前服务器角色是Observer。

## 14：Zookeeper的数据同步通常分为四类：

　　直接差异化同步（DIFF同步）、先回滚再差异化同步（TRUNC+DIFF同步）、仅回滚同步（TRUNC同步）、全量同步（SNAP同步）

## 15： zookeeper是如何保证事务的顺序一致性的？

　　zookeeper采用了全局递增的事务Id来标识，首先会向其他的server发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行。

## 16：zookeeper负载均衡和nginx负载均衡区别

- zookeeper
  - 不存在单点问题，zab机制保证单点故障可重新选举一个leader
  - 只负责服务的注册与发现，不负责转发，减少一次数据交换（消费方与服务方直接通信）
  - 需要自己实现相应的负载均衡算法
- nginx
  - 存在单点问题，单点负载高数据量大,需要通过KeepAlived+LVS备机实现高可用
  - 每次负载，都充当一次中间人转发角色，增加网络负载量（消费方与服务方间接通信）
  - 自带负载均衡算法

## 17：Zookeeper  Watcher监听

　　Zookeeper允许客户端向服务端的某个Znode注册一个Watcher监听，当服务端的一些指定事件触发了这个Watcher，服务端会向指定客户端发送一个事件通知来实现分布式的通知功能，然后客户端根据Watcher通知状态和事件类型做出业务上的改变。

## 18：Watcher特性总结

1. 一次性，无论是服务端还是客户端，一旦一个Watcher被触发，Zookeeper都会将其从相应的存储中移除。这样的设计有效的减轻了服务端的压力，不然对于更新非常频繁的节点，服务端会不断的向客户端发送事件通知，无论对于网络还是服务端的压力都非常大。

2. 客户端串行执行，客户端Watcher回调的过程是一个串行同步的过程。

3. 轻量，Watcher通知非常简单，只会告诉客户端发生了事件，而不会说明事件的具体内容。客户端向服务端注册Watcher的时候，并不会把客户端真实的Watcher对象实体传递到服务端，仅仅是在客户端请求中使用boolean类型属性进行了标记。

4. watcher event异步发送watcher的通知事件从server发送到client是异步的，这就存在一个问题，不同的客户端和服务器之间通过socket进行通信，由于网络延迟或其他因素导致客户端在不通的时刻监听到事件，由于Zookeeper本身提供了ordering guarantee，即客户端监听事件后，才会感知它所监视znode发生了变化。所以我们使用Zookeeper不能期望能够监控到节点每次的变化。Zookeeper只能保证最终的一致性，而无法保证强一致性。

5. 注册watcher getData、exists、getChildren

6. 触发watcher create、delete、setData

7. 当一个客户端连接到一个新的服务器上时，watch将会被以任意会话事件触发。当与一个服务器失去连接的时候，是无法接收到watch的。而当client重新连接时，如果需要的话，所有先前注册过的watch，都会被重新注册。通常这是完全透明的。只有在一个特殊情况下，watch可能会丢失：对于一个未创建的znode的exist watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上之前又删除了，这种情况下，这个watch事件可能会被丢失。

## 19 : zookeeper是怎么选举出来leader的？或者说选举机制是怎样的？

> 当leader崩溃或者leader失去大多数的follower时，zk就进入恢复模式，恢复模式即需要重新选举出一个新的leader，让所有的节点都恢复到一个正确的状态。


Zk的选举算法有两种：一种是基于`BasicLeaderElection`实现的，另外一种是基于`FastLeaderElection`算法实现的。系统默认的选举算法为`FastLeaderElection`

 

### 基于BasicLeaderElection算法的选举机制：

（1）选举线程是一个独立的线程，其主要功能是对投票结果进行统计，并选出推荐的Server；

（2）选举线程首先向所有节点发起一次询问(包括自己)；在收到回复后，验证是否是自己发起的询问(验证zxid是否一致)，然后获取对方的id(myid)，并存储到当前询问对象列表中，最后获取对方提议的leader相关信息(id,zxid)，并将这些信息存储到当次选举的投票记录表中；

（3）收到所有节点回复以后，就计算出zxid最大的那个节点，并将这个节点相关信息设置成下一次要投票的节点；

（5）线程将当前zxid最大的Server设置为当前Server要推荐的Leader，如果此时获胜的Server获得n/2 + 1的Server票数，设置当前推荐的leader为获胜的Server，将根据获胜的Server相关信息设置自己的状态，否则，继续这个过程，直到leader被选举出来。 通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n+1，且存活的Server的数目不得少于n+1. 每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复

 

### 基于FastLeaderElection算法的选举机制：

FastLeaderElection算法选举流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和 zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。

 

#### 基于FastLeaderElection算法的选举机制的两种情况下选举：

##### 第一种：全新选举

假设目前有 5 台服务器，每台服务器均没有数据，它们的编号分别是1,2,3,4,5,按编号依次启动，

它们的选择举过程如下：

l  服务器 1 启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器 1 的状态一直属于 Looking。

l  服务器 2 启动，给自己投票，同时与之前启动的服务器 1 交换结果，由于服务器 2 的编号大所以服务器 2 胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是 LOOKING。

l  服务器 3 启动，给自己投票，同时与之前启动的服务器 1,2 交换信息，由于服务器 3 的编号最大所以服务器 3 胜出，此时投票数正好大于半数，所以服务器 3 成为领导者，服务器 1,2 成为小弟。

l  服务器 4 启动，给自己投票，同时与之前启动的服务器 1,2,3 交换信息，尽管服务器 4 的编号大，但之前服务器 3 已经胜出，所以服务器 4 只能成为小弟。

l  服务器 5 启动，后面的逻辑同服务器 4 成为小弟

 

##### 第二种：非全新选举

对于运行正常的 zookeeper 集群，中途有机器 down 掉，需要重新选举时，选举过程就需要加入数据 ID、服务器 ID 和逻辑时钟。

这样选举的标准就变成：

1、逻辑时钟小的选举结果被忽略，重新投票；

2、统一逻辑时钟后，数据 id 大的胜出；

3、数据 id 相同的情况下，服务器 id 大的胜出；

根据这个规则选出 leader。

## 20 : zookeeper为什么能保证全局数据一致性？

1. 首先，zookeeper集群每个节点都可以接收到客户端请求；

2. 其次，客户端请求分为两种请求，一种请求是事务性请求，另一种是非事务性请求，下边就这两种请求展开论述：
   1. 事务性请求：
      - 当事务性请求是从节点接收到的，就会将请求转发给主节点，然后让主节点按照时间顺序来指定各个节点完 
      - 成请求；当事务性请求是主节点接收到的，主节点将会直接自己按照客户端请求顺序来处理请求；
   2. 非事务性请求：任何节点收到了都可以自行处理；

## 21 : 主从集群和主备集群的区别？

1. 主从集群：一主多从，主从各司其职，主节点负责资源分配和任务调度，从节点负责具体的执行；

2. 主备集群：一主一备，主要是为了解决单点故障问题，便于备份恢复

## 22 : zookeeper都做了什么？

1.  命名服务：注册中心，被用作提供服务地址，例如dubbo中zk就是被用作注册中心的，专门记录一些全局路径，需要先在zk中注册地址，然后当有请求需要访问某个地址的时候，可以直接在zk中找到对应的地址去请求相应服务，就类似于一个总目录一样；

2. 配置信息(watcher监控机制)：程序分布式的部署在不同的机器上，将程序的配置信息放在zk的znode下，当有配置发生改变时，也就是znode发生变化时，可以通过改变zk中某个目录节点的内容，利用watcher通知给各个客户端，从而更改配置。

3. 集群管理：无非就是是否有新的机器加入或者机器被删除，以及选举主节点

4. 分布式锁：(监控机制，这块理解的还不是很透彻)

​        有了zookeeper的全局一致性文件系统，锁的问题变得容易。锁服务可以分为两类，一个是保持独占，另一个是控制时序。

​        对于独占锁，我们将zookeeper上的一个znode看作是一把锁，通过createznode的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的distribute_lock 节点就释放出锁。

​         对于控制时序锁， distribute_lock 已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选master一样，编号最小的获得锁，用完删除，依次执行。

## 23 : zk节点宕机如何处理？

- Zookeeper本身也是集群，推荐配置不少于3个服务器。Zookeeper自身也要保证当一个节点宕机时，其他节点会继续提供服务。
- 如果是一个Follower宕机，还有2台服务器提供访问，因为Zookeeper上的数据是有多个副本的，数据并不会丢失；
- 如果是一个Leader宕机，Zookeeper会选举出新的Leader。
- ZK集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在ZK节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。

## 24 : Zookeeper同步流程

1、Leader等待server连接；
2、Follower连接leader，将最大的zxid发送给leader；
3、Leader根据follower的zxid确定同步点；
4、完成同步后通知follower 已经成为uptodate状态；
5、Follower收到uptodate消息后，又可以重新接受client的请求进行服务了。

## 25 : 机器中为什么会有leader？

在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，于是就需要进行leader选举。

## 26 : Zookeeper数据复制

Zookeeper作为一个集群提供一致的数据服务，自然，它要在所有机器间做数据复制。数据复制的好处：
1、容错：一个节点出错，不致于让整个系统停止工作，别的节点可以接管它的工作；
2、提高系统的扩展能力 ：把负载分布到多个节点上，或者增加节点来提高系统的负载能力；
3、提高性能：让客户端本地访问就近的节点，提高用户访问速度。

从客户端读写访问的透明度来看，数据复制集群系统分下面两种：
1、写主(WriteMaster) ：对数据的修改提交给指定的节点。读无此限制，可以读取任何一个节点。这种情况下客户端需要对读与写进行区别，俗称读写分离；
2、写任意(Write Any)：对数据的修改可提交给任意的节点，跟读一样。这种情况下，客户端对集群节点的角色与变化透明。

对zookeeper来说，它采用的方式是写任意。通过增加机器，它的读吞吐能力和响应能力扩展性非常好，而写，随着机器的增多吞吐能力肯定下降（这也是它建立observer的原因），而响应能力则取决于具体实现方式，是延迟复制保持最终一致性，还是立即复制快速响应。

## 26 : 应用场景

### 命名服务

命名服务是指通过指定的名字来获取资源或者服务的地址，利用zk创建一个全局的路径，即是唯一的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，或者一个远程的对象等等。

也就是我们常说的注册中心，进行服务的发布与消费，通过ZooKeeper协议进行服务的注册，将地址作为内容放到临时结点上，然后消费者可以通过ZooKeeper暴露出来的地址访问指定的服务名称获得服务的地址，然后服务间进行通信即可，与注册中心就无关了，一旦地址发生修改，ZooKeeper也会通过Watcher机制通知消费方修改地址，而且集群环境下只需要添加多个地址，然后再消费方程序中进行负载均衡算法的实现即可；

### 集群管理

所谓集群管理无在乎两点：是否有机器退出和加入、选举master。
对于第一点，所有机器约定在父目录下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与 zookeeper的连接断开，其所创建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除，于是，所有人都知道：它上船了。
新机器加入也是类似，所有机器收到通知：新兄弟目录加入，highcount又有了，对于第二点，我们稍微改变一下，所有机器创建临时顺序编号目录节点，每次选取编号最小的机器作为master就好。

集群的管理主要有两点，机器的加入与退出，Master的选举
对于第一点我们可以让所有机器约好在同一个父节点下面创建临时节点，然后都监听父节点的节点变化，一旦服务宕机，或者什么其他情况，临时节点创建或者消失就会被集群中其他的机器收到通知，因此可以实现集群中机器的加入和退出对所有的成员来说是可知的；而Master的选举我们可以通过顺序节点，一旦Master宕机就选择集群中编号最小的机器作为Master其他机器跟着新的Master走就可以了

### 统一配置管理

程序分布式的部署在不同的机器上，将程序的配置信息放在zk的znode下，当有配置发生改变时，也就是znode发生变化时，可以通过改变zk中某个目录节点的内容，利用watcher通知给各个客户端，从而更改配置。

将所有的配置文件都放在一个父节点下面，创建一个持久化节点，程序中只需要读取各自的配置文件信息即可，同时监听配置节点内容的修改，一旦内容修改就重启服务等系列的操作，实现了统一配置文件的处理

### 分布式锁

分为两种

#### 1.保持独占锁

在业务逻辑之前，每次都去尝试创建一个临时节点，谁创建到了这个临时节点，谁就拿到了锁，进行相应的业务逻辑操作，在逻辑操作结束之后对节点进行销毁也就是释放锁即可’

#### 2.顺序执行锁

在业务逻辑之前，都在一个已经存在的节点下面创建一个临时顺序节点，保证每次都是顺序编号最小的节点进行业务逻辑操作，当逻辑操作结束后，删除该节点，然后继续是顺序编号最小的节点进行业务逻辑操作，同样可以保证每次都是只有一个节点也就是一个线程在进行逻辑操作

#### 获得分布式锁的流程

在获取分布式锁的时候在locker节点下创建临时顺序节点，释放锁的时候删除该临时节点。客户端调用createNode方法在locker下创建临时顺序节点，
然后调用getChildren(“locker”)来获取locker下面的所有子节点，注意此时不用设置任何Watcher。客户端获取到所有的子节点path之后，如果发现自己创建的节点在所有创建的子节点序号最小，那么就认为该客户端获取到了锁。如果发现自己创建的节点并非locker所有子节点中最小的，说明自己还没有获取到锁，此时客户端需要找到比自己小的那个节点，然后对其调用exist()方法，同时对其注册事件监听器。之后，让这个被关注的节点删除，则客户端的Watcher会收到相应通知，此时再次判断自己创建的节点是否是locker子节点中序号最小的，如果是则获取到了锁，如果不是则重复以上步骤继续获取到比自己小的一个节点并注册监听。当前这个过程中还需要许多的逻辑判断。

### Zookeeper队列管理（文件系统、通知机制）

两种类型的队列：
1、同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。
2、队列按照 FIFO 方式进行入队和出队操作。
第一类，在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。
第二类，和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。在特定的目录下创建PERSISTENT_SEQUENTIAL节点，创建成功时Watcher通知等待的队列，队列删除序列号最小的节点用以消费。此场景下Zookeeper的znode用于消息存储，znode存储的数据就是消息队列中的消息内容，SEQUENTIAL序列号就是消息的编号，按序取出即可。由于创建的节点是持久化的，所以不必担心队列消息的丢失问题。