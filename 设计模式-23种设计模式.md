# 设计模式

## 1 单例模式

对于需要的单例的类，其内部要有 static 修饰的类名。

### 优点

- 由于单例模式在内存中只有一个实例， 减少了内存开支， 特别是一个对象需要频繁地创建、 销毁时， 而且创建或销毁时性能又无法优化， 单例模式的优势就非常明显。
- 由于单例模式只生成一个实例， 所以减少了系统的性能开销， 当一个对象的产生需要比较多的资源时， 如读取配置、 产生其他依赖对象时， 则可以通过在应用启动时直接产生一个单例对象， 然后用永久驻留内存的方式来解决（ 在Java EE中采用单例模式时需要注意JVM垃圾回收机制） 。
- 单例模式可以避免对资源的多重占用， 例如一个写文件动作， 由于只有一个实例存在内存中， 避免对同一个资源文件的同时写操作。
- 单例模式可以在系统设置全局的访问点， 优化和共享资源访问， 例如可以设计一个单例类， 负责所有数据表的映射处理。

    ****

### 缺点

- 单例模式一般没有接口， 扩展很困难， 若要扩展， 除了修改代码基本上没有第二种途径可以实现。 单例模式为什么不能增加接口呢？ 因为接口对单例模式是没有任何意义的， 它要求“自行实例化”， 并且提供单一实例、 接口或抽象类是不可能被实例化的。 当然， 在特殊情况下， 单例模式可以实现接口、 被继承等， 需要在系统开发中根据环境判断。
- 单例模式对测试是不利的。 在并行开发环境中， 如果单例模式没有完成， 是不能进行测试的， 没有接口也不能使用mock的方式虚拟一个对象。
- 单例模式与单一职责原则有冲突。 一个类应该只实现一个逻辑， 而不关心它是否是单例的， 是不是要单例取决于环境， 单例模式把“要单例”和业务逻辑融合在一个类中。



## 2 工厂方法模式



## 3 抽象工厂模式

横向扩展容易， 纵向扩展困难。 

 纵向扩展困难 ：如原本有两个产品，现在要增加一个产品，需要在抽象类AbstractCreator中增加一个方法，这样一来，继承这个抽象类的实体类都需要更改。

横向扩展容易 ：如原本有两个产品，有形状的字段，有圆形、正方形，现在要增加梯形的，只要再创建一个工厂类，专门负责梯形产品的创建。



## 4 模板方法模式

模板方法：就是按照一定的顺序执行方法

```java
public abstract class AbstractClass {
	//基本方法
	protected abstract void doSomething();
	//基本方法
	protected abstract void doAnything();
	//模板方法
	public void templateMethod(){
		/*
		 * 调用基本方法， 完成相关的逻辑
	 	 */
		this.doAnything();
		this.doSomething();
	}
}
```

如 templateMethod() 规定 需要先执行 doAnything() 再执行 doSomething()

其他继承这个抽象类的实体类，不需要重复写 templateMethod() 方法，直接调用即可。

​        **注意** 抽象模板中的基本方法尽量设计为 protected 类型， 符合迪米特法则， 不需要暴露的属性或方法尽量不要设置为protected类型。 实现类若非必要， 尽量不要扩大父类中的访问权限。

### 优点

- 封装不变部分， 扩展可变部分
- 提取公共部分代码， 便于维护
- 行为由父类控制， 子类实现



## 5 建造者模式

​        建造者模式（ Builder Pattern） 也叫做生成器模式

​        将一个复杂对象的构建与它的表示分离， 使得同样的构建过程可以创建不同的表示。 

### 优点

- 封装性
  - 使用建造者模式可以使客户端不必知道产品内部组成的细节， 如例子中我们就不需要关
    心每一个具体的模型内部是如何实现的， 产生的对象类型就是 CarModel。
- 建造者独立， 容易扩展
  - BenzBuilder 和 BMWBuilder 是相互独立的， 对系统的扩展非常有利。
- 便于控制细节风险
  - 由于具体的建造者是独立的， 因此可以对建造过程逐步细化， 而不对其他的模块产生任何影响。

### 使用场景

- 相同的方法， 不同的执行顺序， 产生不同的事件结果时， 可以采用建造者模式。
- 多个部件或零件， 都可以装配到一个对象中， 但是产生的运行结果又不相同时， 则可以使用该模式。
- 产品类非常复杂， 或者产品类中的调用顺序不同产生了不同的效能， 这个时候使用建造者模式非常合适。
- 在对象创建过程中会使用到系统中的一些其他对象， 这些对象在产品对象的创建过程中不易得到时， 也可以采用建造者模式封装该对象的创建过程。 该种场景只能是一个补偿方法， 因为一个对象不容易获得， 而在设计阶段竟然没有发觉， 而要通过创建者模式柔化创建过程， 本身已经违反设计的最初目标。

## 6 代理模式

​        代理模式也叫做委托模式， 它是一项基本设计技巧。 许多其他的模式， 如状态模式、 策略模式、 访问者模式本质上是在更特殊的场合采用了委托模式， 而且在日常的应用中， 代理模式可以提供非常好的访问控制。

​        Spring AOP， 这是一个非常典型的动态代理。

****

### 动态代理



## 7 原型模式

​         不通过new关键字来产生一个对象， 而是通过对象复制来实现的模式就叫做原型模式。

​         这种不通过new关键字来产生一个对象， 而是通过对象复制来实现的模式就叫做原型模式。

​         实现一个接 Cloneable 接口， 然后重写clone方法， 就完成了原型模式！

### 优点

- 性能优良
  - 原型模式是在内存二进制流的拷贝， 要比直接new一个对象性能好很多， 特别是要在一个循环体内产生大量的对象时， 原型模式可以更好地体现其优点。
- 逃避构造函数的约束
  - 这既是它的优点也是缺点， 直接在内存中拷贝， 构造函数是不会执行的。 优点就是减少了约束， 缺点也是减少了约束， 需要在实际应用时考虑。



## 8 中介者模式

### 优点

减少类间的依赖， 把原有的一对多的依赖变成了一对一的依赖，类只依赖中介者， 减少了依赖， 当然同时也降低了类间的耦合。

### 缺点

中介者会膨胀得很大， 而且逻辑复杂， 原本N个对象直接的相互依赖关系转换为中介者和类的依赖关系， 同事类越多， 中介者的逻辑就越复杂。



## 9 命令模式

命令模式是一个高内聚的模式

### 优点

- 类间解耦
  - 调用者角色与接收者角色之间没有任何依赖关系， 调用者实现功能时只需调用Command
    抽象类的execute方法就可以， 不需要了解到底是哪个接收者执行。
- 可扩展性
  - Command的子类可以非常容易地扩展， 而调用者Invoker和高层次的模块Client不产生严
    重的代码耦合。
- 命令模式结合其他模式会更优秀
  - 命令模式可以结合责任链模式， 实现命令族解析任务； 结合模板方法模式， 则可以减少
    Command子类的膨胀问题

## 10 责任链模式

​        定义:  使多个对象都有机会处理请求， 从而避免了请求的发送者和接受者之间的耦合关系。 将这些对象连成一条链， 并沿着这条链传递该请求， 直到有对象处理它为止。 

### 优点

​        责任链模式非常显著的优点是将请求和处理分开。 请求者可以不用知道是谁处理的， 处理者可以不用知道请求的全貌（ 例如在J2EE项目开发中， 可以剥离出无状态Bean由责任链处理） ， 两者解耦， 提高系统的灵活性。

### 缺点

​         一是性能问题， 每个请求都是从链头遍历到链尾， 特别是在链比较长的时候， 性能是一个非常大的问题。 

​        二是调试不很方便， 特别是链条比较长，环节比较多的时候， 由于采用了类似递归的方式， 调试的时候逻辑可能比较复杂。

## 11 装饰模式



## 12 策略模式



## 13 适配器模式